<html>
  <head>

  </head>
  <body>
        <button onclick="connect()">Connect to GAN356i v3 smart cube</button>
    <!-- <button onclick="printData()">Click me</button> -->
    <div id="log"></div>
    <div id="tmpsaver"></div>
    <div id="tmpsaverbad"></div>
    <div id="scramble"></div>
    <div id=kostka style="width:200px; height:219px">
    </div>
  <button id="buttonVW">WV train</button>
  <button id="buttonPLL">PLL train</button>
  <button id="buttonBLD">BLD train</button>
  <button id="buttonReset">Reset Cube</button>
  <label for="BLDTrainMode">BLD train mode:</label>
<select name="BLDTrainMode" id="BLDTrainMode">
  <option value="Normal">Normal</option>
  <option value="Corners">Corners only</option>
  <option value="Edges">Edges only</option>
  <option value="Pairity">Pairity UFR</option>
  <option value="Corners 3-twists">Corners 3-twists</option>
  <option value="Edges 2-flips">Edges 2-flips</option>
</select>
<label for="BLDPairity">pairity</label>
<select name="BLDpairity" id="BLDpairity">
  <option value="yes">yes</option>
  <option value="no">no</option>
  <option value="all">all</option>
</select>
  <br>
  <div id="bld trainer">BLD trainer edges</div>
  <label for="bufferEdges">Choose a buffer:</label>
<select name="bufferEdges" id="bufferEdges">
  <option value="UF">UF</option>
  <option value="UB">UB</option>
</select>
<label for="firstTarget">Choose a first target:</label>
<select name="firstTarget" id="firstTarget">
  <option value="A">A</option>
  <option value="B">B</option>
  <option value="C">C</option>
  <option value="D">D</option>
  <option value="E">E</option>
  <option value="F">F</option>
  <option value="G">G</option>
  <option value="H">H</option>
  <option value="I">I</option>
  <option value="J">J</option>
  <option value="K">K</option>
  <option value="L">L</option>
  <option value="M">M</option>
  <option value="N">N</option>
  <option value="O">O</option>
  <option value="P">P</option>
  <option value="R">R</option>
  <option value="S">S</option>
  <option value="T">T</option>
  <option value="U">U</option>
  <option value="W">W</option>
  <option value="Z">Z</option>
</select>
<button id="buttonEdges">BLD edges train</button>
  <br>
  <div id="bld trainerc">BLD trainer corners</div>
  <label for="bufferCorners">Choose a buffer:</label>
<select name="bufferCorners" id="bufferCorners">
  <option value="UFR">UFR</option>
  <option value="UBR">UBR</option>
</select>
<label for="firstTargetC">Choose a first target:</label>
<select name="firstTargetC" id="firstTargetC">
  <option value="A">A</option>
  <option value="B">B</option>
  <option value="C">C</option>
  <option value="D">D</option>
  <option value="E">E</option>
  <option value="F">F</option>
  <option value="G">G</option>
  <option value="H">H</option>
  <option value="I">I</option>
  <option value="J">J</option>
  <option value="K">K</option>
  <option value="L">L</option>
  <option value="M">M</option>
  <option value="O">O</option>
  <option value="P">P</option>
  <option value="R">R</option>
  <option value="S">S</option>
  <option value="T">T</option>
  <option value="U">U</option>
  <option value="W">W</option>
  <option value="Z">Z</option>
</select>
<button id="buttonCorners">BLD corners train</button>

  <br>
  <div id="bld trainercm">BLD trainer corners</div>
  <label for="bufferCornersM">Choose a buffer:</label>
<select name="bufferCornersM" id="bufferCornersM">
  <option value="UFR">UFR</option>
  <option value="UBR">UBR</option>
</select>
<label for="numCM">Number of random algs:</label>
<select name="numCM" id="numCM">
  <option value="20">20</option>
  <option value="100">100</option>
  <option value="386">all(386)</option>
</select>
<label for="thCM">Threshold(seconds):</label>
<select name="thCM" id="thCM">
  <option value="3">3</option>
  <option value="2">2.5</option>
  <option value="1.5">2</option>
  <option value="1.2">1.5</option>
</select>
<button id="buttonCornersM">BLD corners marathon train</button>

  <br>
   <div id="bld trainerem">BLD trainer edges</div>
  <label for="bufferEdgesM">Choose a buffer:</label>
<select name="bufferEdgesM" id="bufferEdgesM">
  <option value="UF">UF</option>
  <option value="UB">UB</option>
</select>
<label for="numEM">Number of random algs:</label>
<select name="numEM" id="numEM">
  <option value="20">20</option>
  <option value="100">100</option>
  <option value="440">all(440)</option>
</select>
<label for="thEM">Threshold(seconds):</label>
<select name="thEM" id="thEM">
  <option value="3">3</option>
  <option value="2">2.5</option>
  <option value="1.5">2</option>
  <option value="1.2">1.5</option>
</select>
<button id="buttonEdgesM">BLD edges marathon train</button>

<div class="container">
    <div style="background-color:white" id="tableTimes" class="left-element">
</div>
    <div class="right-element" id="logBld">
    </div>
</div>

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="./table.css"  />
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" ></script>
<script type="text/javascript" src="./lib/cube_map.js" ></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script>
  <script src="./lib/cube.js" type="text/javascript"></script>
  <script src="./lib/solve.js" type="text/javascript"></script>
  <script src="./lib/async.js" type="text/javascript"></script>
  <script src="./lib/jquery.json.js" type="text/javascript"></script>
  <!-- <script src="./lib/worker.js" type="text/javascript"></script> -->
  <script src="AnimCube3.js"></script>

      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script type="text/javascript" src="https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js"></script>
    <script>
      const cuber = new Cube();
      // Cube.initSolver();
// localStorage.setItem("lastname", "Smith");
      /*Retreive or generate times list*/
      Array.prototype.shuffle = function() {
  var i = this.length, j, temp;
  if ( i == 0 ) return this;
  while ( --i ) {
     j = Math.floor( Math.random() * ( i + 1 ) );
     temp = this[i];
     this[i] = this[j];
     this[j] = temp;
  }
  return this;
}
var times={}
generateJSONstorage()

// These typically take from 0.01s to 0.4s, rarely up to 2s
// cuber.move("U B R F2 B2 F R' D").solve();        // => "D2 B' R' B L' B ..."
// cuber.solve();  // => "R B' R U' D' R' ..."
// Cube.asyncInit('lib/worker.js', function() {
    // Initialized
//     Cube.asyncSolve(cuber, function(algorithm) {
//         console.log(algorithm);
//     });
// });
    var wv_algs=["U' R' F R U R U' R' F'","R2 D R' U' R D' R2","R U' R' U R' U' R U' R' U2 R","U' R U' R' U2 R U' R' U2 R U R'","R U R' U' R U' R'","R U' R'","R U' R D' R U2 R' D R U2 R","U' R' F' R U2 R U2 R' F","U R U2 R'","U R U' R' U' R' F R U R U' R' F'","U' L' U R U' R' L","U R2 D R' U2 R D' R2","U R U2 R2 U' R U' R' U2 R","U' R' F2 R F2 U L' U L","R U R2 U' R2 U' R2 U2 R","U R' U' R2 U' R2 U2 R","U R U' R' U R U2 R'","R U' R' U R U2 R2 U' R2 U' R2 U2 R"];
    var wv_train_algs=[]
    var setup_last_slot_algs=["U' R U' R'","U' R U R'","U' R U R' U R U R'", "U2 R U R' U' R U R'","U' R U R' U2 R U' R'"]
    var pll_algs=[["L2", "B2", "L'", "F'", "L", "B2", "L'", "F", "L'"],
["L2", "F2", "L", "B", "L'", "F2", "L", "B'", "L"],
["R'", "U'", "F'", "R", "U", "R'", "U'", "R'", "F", "R2", "U'", "R'", "U'", "R", "U", "R'", "U", "R"],
["R2", "U", "R'", "U", "R'", "U'", "R", "U'", "R2", "U'", "D", "R'", "U", "R", "D'"],
["R'", "U'", "R", "U", "D'", "R2", "U", "R'", "U", "R", "U'", "R", "U'", "R2", "D"],
["R2", "U'", "R", "U'", "R", "U", "R'", "U", "R2", "U", "D'", "R", "U'", "R'", "D"],
["R", "U", "R'", "U'", "D", "R2", "U'", "R", "U'", "R'", "U", "R'", "U", "R2", "D'"],
["R'", "U", "L'", "U2", "R", "U'", "R'", "U2", "R", "L", "U'"],
["R", "U", "R'", "F'", "R", "U", "R'", "U'", "R'", "F", "R2", "U'", "R'"],
["R", "U'", "R'", "U'", "R", "U", "R", "D", "R'", "U'", "R", "D'", "R'", "U2", "R'"],
["R2", "F", "R", "U", "R", "U'", "R'", "F'", "R", "U2", "R'", "U2", "R"],
["R", "U", "R'", "U'", "R'", "F", "R2", "U'", "R'", "U'", "R", "U", "R'", "F'"],
["L'", "B", "L", "F'", "L'", "B'", "L", "F", "L'", "B'", "L", "F'", "L'", "B", "L", "F"],
["R", "U", "R'", "U", "R", "U", "R'", "F'", "R", "U", "R'", "U'", "R'", "F", "R2", "U'", "R'", "U2", "R", "U'", "R'"],
["R'", "U", "R", "U'", "R'", "F'", "U'", "F", "R", "U", "R'", "F", "R'", "F'", "R", "U'", "R"],
["R'", "U", "R'", "U'", "B'", "R'", "B2", "U'", "B'", "U", "B'", "R", "B", "R"],
["F", "R", "U'", "R'", "U'", "R", "U", "R'", "F'", "R", "U", "R'", "U'", "R'", "F", "R", "F'"],
["R2", "L2", "D", "R2", "L2", "U2", "R2", "L2", "D", "R2", "L2"],
["R2", "U'", "R'", "U'", "R", "U", "R", "U", "R", "U'", "R"],
["R2", "U", "R", "U", "R'", "U'", "R'", "U'", "R'", "U", "R'"],
["R2", "U'", "R'", "U'", "R", "U", "R", "U", "R", "U'", "R", "U'", "R2", "U'", "R'", "U'", "R", "U", "R", "U", "R", "U'", "R"]]
    pll_algs=pll_algs.slice()
    /*generate all aufs*/
    pll_algs=pll_algs.concat(pll_algs.map(x=>x.concat(['U']))).concat(pll_algs.map(x=>x.concat(["U'"]))).concat(pll_algs.map(x=>x.concat(['U2'])))
    wv_algs=wv_algs.map(x => x.split(' '));
    // wv_algs_mirror=wv_algs.map(x => mirror_moves(x));
    // wv_algs=wv_algs.concat(wv_algs_mirror)
    // wv_algs_back=wv_algs.map(x => back_moves(x))
    var alg_no=0;
    var buf=''
    var ft=''

    var setup_case=[];
    var mvcnt=0
    var st=0;
    var end=0;
    var base_rot=.6;
    document.addEventListener('keypress', (event) => {
      var name = event.key;
      var code = event.code;
      if(name == 'q'){base_rot-=.1}
      if(name == 'w'){base_rot+=.1}
    }, false);


      // let key_ = [0xa6, 0xe, 0xa0, 0x5c, 0x43, 0x3d, 0x16, 0x7, 0x20, 0x5, 0x18, 0x54, 0x42, 0x11, 0x12, 0x53];
      // let iv_ = [0xb6, 0xf, 0x90, 0x5c, 0x33, 0xac, 0x76, 0x27, 0x20, 0x95, 0x78, 0x14, 0x32, 0x12, 0x2, 0x43];

      // let key_ = [ 0xa6, 0x0e, 0x1f, 0x46, 0x43, 0xbb, 0x16, 0x5c, 0x29, 0x53, 0x5b, 0xff, 0x7e, 0x42, 0x12, 0x5f ];
      // let iv_ = [ 0xb6, 0x03, 0x8e, 0x5d, 0x33, 0xac, 0xd5, 0x69, 0x7e, 0xd6, 0xb6, 0x8f, 0x3d, 0x32, 0xa9, 0x4f ];

      // let key_ = [0x1, 0x44, 0x43, 0x5c, 0x43, 0x3d, 0x16, 0x7, 0x20, 0x5, 0x18, 0x54, 0x42, 0x11, 0x12, 0x53];
      // let iv_ = [0x11, 0x45, 0x33, 0x5c, 0x33, 0xac, 0x76, 0x27, 0x20, 0x95, 0x78, 0x14, 0x32, 0x12, 0x2, 0x43];
      const moves = new Array( "U'", "U", "R'", "R", "F'", "F", "D'", "D", "L'", "L", "B'", "B" )
      const movesCube = new Array( "U", "U'", "R", "R'", "F", "F'", "D", "D'", "L", "L'", "B", "B'" )
      const movesCubeBLD = new Array( "U", "U'", "F", "F'", "L", "L'", "D", "D'", "B", "B'", "R", "R'" )
      let allmoves = new Array()
      const device_key = new Uint8Array([0xa5, 0x0c, 0x5e, 0x34, 0x12, 0xab]);
      const GAN_V2_KEY = new Uint8Array([
        0x01, 0x02, 0x42, 0x28, 0x31, 0x91, 0x16, 0x07, 0x20, 0x05, 0x18, 0x54, 0x42, 0x11, 0x12, 0x53,
      ]);
      const GAN_V2_IV = new Uint8Array([
        0x11, 0x03, 0x32, 0x28, 0x21, 0x01, 0x76, 0x27, 0x20, 0x95, 0x78, 0x14, 0x32, 0x12, 0x02, 0x43,
      ]);

      let key = new Uint8Array(GAN_V2_KEY);
      let iv = new Uint8Array(GAN_V2_IV);

      for (let i = 0; i < device_key.length; i++) {
        key[i] = (key[i] + device_key[i]) % 255;
        iv[i] = (iv[i] + device_key[i]) % 255;
      }
      // Pass key and iv to AES library
      // let aesCtr = new aesjs.ModeOfOperation.ctr(aesKey, aesIv);
      
      //other way to compute device key
function mirror_moves(moves) {
  const unchanged = ["U", "U'", "D", "D'"];
  const switchArr = [    ["U","U'","D","D'","R", "R'", "L'", "L", "F", "F'", "B'", "B"],
    ["U'","U","D'","D","L'", "L", "R", "R'", "F'", "F", "B", "B'"]
  ];
  const movesMirror = moves.map(x => "UDLRFB"["UDRLFB".indexOf(x[0])]+(x.length==1?"'":x[1]=="'"?"":"2"))
  return movesMirror;
}

function back_moves(moves) {
  const unchanged = ["U", "U'", "D", "D'"];
  const switchArr = [    ["U","U'","D","D'","R", "R'", "L'", "L", "F", "F'", "B'", "B"],
    ["U'","U","D'","D","R'", "R", "L", "L'", "B'", "B", "F", "F'"]
  ];
  const movesBack = moves.map(x => "UDLRFB"["UDLRBF".indexOf(x[0])]+(x.length==1?"'":x[1]=="'"?"":"2"))
  return movesBack;
}

function decrypt(value, device_key, device_iv) {
    // console.log('raw bytes:',value)
    if (value.length <= 16) {
        throw new Error("Packet size less than expected length");
    }
    let offset = value.length - 16;
    let end_cipher = value.slice(offset);
    let end_plain = aesDecryptBlock(end_cipher, device_key);
    for (let i = 0; i < 16; i++) {
        end_plain[i] ^= device_iv[i];
        value[offset + i] = end_plain[i];
    }
    // console.log('last bytes decrypted:',value)
    let start_cipher = value.slice(0, 16);
    let start_plain = aesDecryptBlock(start_cipher, device_key);
    for (let i = 0; i < 16; i++) {
        start_plain[i] ^= device_iv[i];
        value[i] = start_plain[i];
    }
    // console.log('everything decrypted:',value)
    return value;
}


function encrypt(value, device_key, device_iv) {
    // console.log('raw bytes:',value)
    if (value.length <= 16) {
        throw new Error("Packet size less than expected length");
    }
    let result = value;
    // let end_cipher = value.slice(offset);
    // let end_plain = aesDecryptBlock(end_cipher, device_key);
    for (let i = 0; i < 16; i++) {
        result[i] ^= device_iv[i];
    }
    let cipher = result.slice(0, 16);
    // console.log('last bytes decrypted:',value)
    
    let start_plain = aesEncryptBlock(cipher, device_key);
    for (let i = 0; i < 16; i++) {
        result[i] = start_plain[i];
    }
    let offset = value.length-16;

    for (let i =0 ; i<16; i++){
      result[offset + i] ^= device_iv[i]
    }
    let end_cipher = result.slice(offset);
    let end_plain = aesEncryptBlock(end_cipher,device_key);
    for (let i =0 ; i<16; i++){
      result[offset + i] = end_plain[i];
    }
    // console.log('everything decrypted:',value)
    return result;
}

// fn encrypt(&self, value: &[u8]) -> Result<Vec<u8>> {
//         if value.len() <= 16 {
//             return Err(anyhow!("Packet size less than expected length"));
//         }

//         // Packets are larger than block size. First encrypt the first 16 bytes
//         // of the packet in place.
//         let mut value = value.to_vec();
//         for i in 0..16 {
//             value[i] ^= self.device_iv[i];
//         }
//         let mut cipher = Block::clone_from_slice(&value[0..16]);
//         let aes = Aes128::new(GenericArray::from_slice(&self.device_key));
//         aes.encrypt_block(&mut cipher);
//         for i in 0..16 {
//             value[i] = cipher[i];
//         }

//         // Decrypt the last 16 bytes of the packet in place. This will overlap
//         // with the decrypted block above.
//         let offset = value.len() - 16;
//         for i in 0..16 {
//             value[offset + i] ^= self.device_iv[i];
//         }
//         let mut cipher = Block::clone_from_slice(&value[offset..]);
//         aes.encrypt_block(&mut cipher);
//         for i in 0..16 {
//             value[offset + i] = cipher[i];
//         }

//         Ok(value)
//     }
// }


function aesDecryptBlock(block, key) {
  let aes = new aesjs.AES(key);
  return aes.decrypt(block);
}

function aesEncryptBlock(block, key) {
  let aes = new aesjs.AES(key);
  return aes.encrypt(block);
}

function extractBits(data, start, count) {
  let result = 0;
  for (let i = 0; i < count; i++) {
    const bit = start + i;
    result <<= 1;
    if ((data[Math.floor(bit / 8)] & (1 << (7 - (bit % 8)))) !== 0) {
      result |= 1;
    }
  }
  return result;
}
function byteString(n) {
  if (n < 0 || n > 255 || n % 1 !== 0) {
      throw new Error(n + " does not fit in a byte");
  }
  return ("000000000" + n.toString(2)).substr(-8)
}
function decodeEdges(value) {
// Decode edges. There are only 11 in the packet because the
// last one is implicit (the one missing).
const edges = new Array(12).fill(0);
const edgeParity = new Array(12).fill(0);
let totalEdgeParity = 0;
const edgesLeft = [...Array(12).keys()];
for (let i = 0; i < 11; i++) {
edges[i] = extractBits(value, 47 + i * 4, 4);
edgeParity[i] = extractBits(value, 91 + i, 1);
totalEdgeParity += edgeParity[i];
edgesLeft.splice(edgesLeft.indexOf(edges[i]), 1);
}
edges[11] = edgesLeft[0];
edgeParity[11] = totalEdgeParity & 1;
return [edges, edgeParity];

}

var facelets_oll="wwwwwwwwwyyyyyyyyydoodoodoodrrdrrdrrdddbbbbbbdggdggdgg"
var facelets_solved="wwwwwwwwwyyyyyyyyyooooooooorrrrrrrrrgggggggggbbbbbbbbb"
var repeating =0;
var tmp_cube = [];
var wv_cube = [];
const solved_cube = [Array(9).fill(10),Array(9).fill(11),Array(9).fill(12),Array(9).fill(13),Array(9).fill(15),Array(9).fill(14)];
var acjs_eye = [];
var acjs_eyeX = [];
var acjs_eyeY = [];
var acjs_cube = []
var acjs_vRotY = [];
var acjs_paint = [];
var acjs_initialMove = [];
var acjs_twistLayer = [];
const movesD = 'UDLRFB'
var activateBLDRegister=0;
var acjs_removeListeners = [];
var params="id=kostka&borderwidth=0&colorscheme=wygbor&facelets="+facelets_oll+"&initmove=#&move="
var pairs=[];
AnimCube3(params);
/*save vw cube solved*/
console.log('saving cube')
copy_cube(wv_cube,acjs_cube['kostka']);
/*save tmp solved*/



//get base values
baseVal=[acjs_eye['kostka'][0],acjs_eye['kostka'][2]];
baseValX=[acjs_eyeX['kostka'][0],acjs_eyeX['kostka'][2]];
baseValY=[acjs_eyeY['kostka'][0],acjs_eyeY['kostka'][2]];

// test rotate
   function setRotY(e, r, b) {
        var t = Math.sin(r),
            o = Math.cos(r),
            a = b[0] * o - b[1] * t,
            i = b[0] * t + b[1] * o;
        return e[0] = a, e[2] = i, e
    }

function rotCube(e,r){
  setRotY(acjs_eye['kostka'],r,baseVal);
  setRotY(acjs_eyeX['kostka'],r,baseValX);
  setRotY(acjs_eyeY['kostka'],r,baseValY);
  acjs_paint['kostka']();  
}

function invAlg(scr){
  return scr.map(x=>(x[0]+(x.length==1?"'":x[1]=="'"?"":"2"))).reverse()
}

const button = document.getElementById('buttonVW');
const buttonPLL = document.getElementById('buttonPLL');
const buttonBLD = document.getElementById('buttonBLD');
const buttonReset = document.getElementById('buttonReset');
const buttonCorners = document.getElementById('buttonCorners');
const buttonEdges = document.getElementById('buttonEdges');
const firstTargetC = document.getElementById('firstTargetC');
const firstTarget = document.getElementById('firstTarget');
const bufferEdges = document.getElementById('bufferEdges');
const bufferCorners = document.getElementById('bufferCorners');

const bufferEdgesM = document.getElementById('bufferEdgesM');
const bufferCornersM = document.getElementById('bufferCornersM');
const numCM = document.getElementById('numCM');
const numEM = document.getElementById('numEM');
const buttonEdgesM = document.getElementById('buttonEdgesM');
const buttonCornersM = document.getElementById('buttonCornersM');

const tCM = document.getElementById('thCM');
const tEM = document.getElementById('thEM');

const TrainMode = document.getElementById('BLDTrainMode');
const pairity = document.getElementById('BLDpairity').value;

button.addEventListener('click', updateButton);
buttonBLD.addEventListener('click', updateButtonBLD);
buttonPLL.addEventListener('click', updateButtonPLL);
buttonReset.addEventListener('click',updateButtonReset);
buttonCorners.addEventListener('click',updateButtonCorners);
buttonEdges.addEventListener('click',updateButtonEdges);
firstTargetC.addEventListener('change',updateGlobalVars);
firstTarget.addEventListener('change',updateGlobalVars);
bufferEdges.addEventListener('change',updateGlobalVars);
bufferCorners.addEventListener('change',updateGlobalVars);

bufferEdgesM.addEventListener('change',updateGlobalVarsM);
bufferCornersM.addEventListener('change',updateGlobalVarsM);
numEM.addEventListener('change',updateGlobalVarsM);
numCM.addEventListener('change',updateGlobalVarsM);
buttonEdgesM.addEventListener('click',updateButtonBLDem);
buttonCornersM.addEventListener('click',updateButtonBLDcm);

function updateGlobalVarsM(typeEl){
  /*update choose list*/
  console.log(typeEl.target.name)
  // active_bld_el='edges BLD'
  // console.log('updating vars',typeEl.target.id)
  active_bld_el_dict=(["numCM","bufferCornersM"].includes(typeEl.target.id))?"corners":"edges"
  active_bld_el=(["numCM","bufferCornersM"].includes(typeEl.target.id))?"corners BLD":"edges BLD"
  active_buf=document.getElementById('buffer'+(active_bld_el=='edges BLD'?'EdgesM':'CornersM')).value
  console.log(active_buf)
  activeNO=parseInt(document.getElementById('num'+(active_bld_el=='edges BLD'?'EM':'CM')).value)
  active_first_let=document.getElementById('firstTarget'+(active_bld_el=='edges BLD'?'':'C')).value
  pairsTable=generateAllPairs(active_bld_el=="edges BLD"?'edges':'corners',active_buf,activeNO).map(x=>x.join(''))
  console.log(pairsTable)
  updatePairs(pairsTable)
  
}

function updateButtonBLDcm() {
  if (buttonCornersM.innerText === 'BLD corners marathon train') {
    active_bld_el='corners BLD'
    copy_cube(acjs_cube['kostka'],solved_cube)
    acjs_paint['kostka']()
    buttonCornersM.innerText += ' in progress...';
  } else {
    alg_no=0;
    status_train=0;
    buttonCornersM.innerText = buttonCornersM.innerText.slice(0,-15);
    document.getElementById('tmpsaver').innerHTML=''
    document.getElementById('tmpsaverbad').innerHTML=''
  }
}

function updateButtonBLDem() {
  if (buttonEdgesM.innerText === 'BLD edges marathon train') {
    active_bld_el='edges BLD'
    copy_cube(acjs_cube['kostka'],solved_cube)
    acjs_paint['kostka']()
    buttonEdgesM.innerText += ' in progress...';
  } else {
    alg_no=0;
    status_train=0;
    buttonEdgesM.innerText = buttonEdgesM.innerText.slice(0,-15);
    document.getElementById('tmpsaver').innerHTML=''
    document.getElementById('tmpsaverbad').innerHTML=''
  }
}

TrainMode.addEventListener('change',updatePairity);
// bufferEdges.addEventListener('change',updateLetterList);
// bufferCorners.addEventListener('change',updateLetterList);

// function updateLetterList(typeEl){
//   active_bld_el=(["firstTargetC","bufferCorners"].includes(typeEl.target.id))?"corners":"edges"
//   active_first_let='firstTarget'+(active_bld_el=='edges BLD'?'':'C')
//   active_buf=document.getElementById('buffer'+(active_bld_el=='edges'?'Edges':'Corners')).value
//   firstTargets = Object.keys(letter_stickers[active_bld_el][active_buf])
//   /*update first target lists*/
//   document.getElementById(active_first_let).innerHTML=""
//   for(i=0;i<firstTargets.length;i++){
//     document.getElementById(active_first_let).innerHTML+="<option value=\""+firstTargets[i]+"\">"+firstTargets[i]+"</option>"
//   }
// }

// function test(){
//   document.getElementById('log').innerHTML=firstTargetC.value
// }

var scramble=[];
function updateButton() {
  if (button.innerText === 'WV train') {
    wv_algs.shuffle()
    wv_train_algs=wv_algs.slice()
    wv_train_algs=wv_train_algs.map(x=>concatAlgs(invAlg(x),setup_last_slot_algs[Math.floor(Math.random()*setup_last_slot_algs.length)].split(' ')))
    console.log('generating scrambles...')
    button.innerText = 'generating scrambles ...';
    Cube.initSolver()
    for(i=0;i<wv_train_algs.length;i++){
        cuber.identity()
        cuber.move(wv_train_algs[i].join(' '))
        scramble=scramble.concat([cuber.solve()])
    }
    button.innerText = 'WV train in progress...';
  } else {
    wv_algs.shuffle()
    button.innerText = button.innerText.slice(0,-15);
    status_train=0;
    alg_no=0;
  }
}
getNumSwaps = function(arr) {
        var cur, cycleLength, i, k, numSwaps, ref, seen, x;
        numSwaps = 0;
        seen = (function() {
          var k, ref, results;
          results = [];
          for (x = k = 0, ref = arr.length - 1; (0 <= ref ? k <= ref : k >= ref); x = 0 <= ref ? ++k : --k) {
            results.push(false);
          }
          return results;
        })();
        while (true) {
          // We compute the cycle decomposition
          cur = -1;
          for (i = k = 0, ref = arr.length - 1; (0 <= ref ? k <= ref : k >= ref); i = 0 <= ref ? ++k : --k) {
            if (!seen[i]) {
              cur = i;
              break;
            }
          }
          if (cur === -1) {
            break;
          }
          cycleLength = 0;
          while (!seen[cur]) {
            seen[cur] = true;
            cycleLength++;
            cur = arr[cur];
          }
          // A cycle is equivalent to cycleLength + 1 swaps
          numSwaps += cycleLength + 1;
        }
        return numSwaps;
      };

function shuffleElements(el_type, pairity){
  permArr = (el_type=='edges'?[0,1,2,3,4,5,6,7,8,9,10,11]:[0,1,2,3,4,5,6,7]).shuffle()
  orArr = el_type=='edges'?[0,0,0,0,0,0,0,0,0,0,0,0]:[0,0,0,0,0,0,0,0]
  permSecond=(el_type=='corners'?[0,1,2,3,4,5,6,7,8,9,10,11]:[0,1,2,3,4,5,6,7])
  if(((getNumSwaps(permArr) % 2) == 1) && pairity=='no'){
    [permArr[0],permArr[1]]=[permArr[1],permArr[0]]
    permSecond= (el_type=='corners'?[0,1,2,3,4,5,6,7,8,9,10,11]:[0,1,2,3,4,5,6,7])
  }else if(((getNumSwaps(permArr) % 2) == 1) && pairity!='no'){
    permSecond= (el_type=='corners'?[3,1,2,0,4,5,6,7,8,9,10,11]:[0,1,3,2,4,5,6,7])
  }else if(((getNumSwaps(permArr) % 2) == 0) && pairity=='yes'){
    [permArr[0],permArr[1]]=[permArr[1],permArr[0]]
    permSecond= (el_type=='corners'?[3,1,2,0,4,5,6,7,8,9,10,11]:[0,1,3,2,4,5,6,7])
  }
  if(el_type == 'edges'){
    orArr=orArr.map(x=>{r=Math.random();return(r<.5?0:1)});
    orArrSum=orArr.reduce((x,y)=>x+y)%2;
    if(orArrSum == 1){orArr[0]=(orArr[0]+1)%2} 
  }else{
    orArr=orArr.map(x=>{r=Math.random();return(r<.333?0:r<.667?1:2)})
    orArrSum=orArr.reduce((x,y)=>x+y)%3;
    if(orArrSum != 0){orArr[0]=(orArr[0]-orArrSum+3)%3} 
    }
  return [permArr, orArr, permSecond]
}

var scramblesBLD=[]
function updateButtonBLD() {
  logMessages={};
  status_train=0;
  alg_no=0;
  tmpScramble=[];
  tmpScrambleMoves=[];
  scramblesBLD=[];
  if (buttonBLD.innerText === 'BLD train' && TrainMode.value!='Pairity' && TrainMode.value!='Corners 3-twists' && TrainMode.value!='Edges 2-flips') {
    console.log('generating scrambles...')
    buttonBLD.innerText = 'generating 100 scrambles ...';
    Cube.initSolver()
    for(i=0;i<5;i++){
        cuber.identity()
        if(TrainMode.value == 'Normal'){
                cuber.randomize()}
        else if(TrainMode.value=='Corners'){
          state=shuffleElements('corners')
          cuber.cp=state[0]
          cuber.co=state[1]
          cuber.ep=state[2]
        }
        else if(TrainMode.value=='Edges'){
          state=shuffleElements('edges')
          cuber.ep=state[0]
          cuber.eo=state[1]
          cuber.cp=state[2]
        }
        scramblesBLD=scramblesBLD.concat([cuber.solve()])
    }
    alg_no=0;
    document.getElementById('logBld').innerHTML=""
    buttonBLD.innerText = 'BLD train in progress...';
    i=0;
  } else if(buttonBLD.innerText === 'BLD train' && TrainMode.value=='Pairity'){
    buttonBLD.innerText = 'BLD train in progress...';
  } else if(buttonBLD.innerText === 'BLD train' && TrainMode.value=='Corners 3-twists'){
    buttonBLD.innerText = 'BLD train in progress...';
  } else if(buttonBLD.innerText === 'BLD train' && TrainMode.value=='Edges 2-flips'){
    buttonBLD.innerText = 'BLD train in progress...';
  }
  else {
    buttonBLD.innerText = buttonBLD.innerText.slice(0,-15);
  }
}

// function simplifyMoves(moves){

// }
function compareMovesToScr(moves,scr){
  if(moves.join(' ') === scr.join(' ')){
    status_train=2
    return "<a style=\"color:#008800;font-size:30\">"+scr.join(' ')+"</a>"
  }
  if(moves.length == 0){
    return "<a style=\"color:#000000;font-size:30\">"+scr.join(' ')+"</a>"
  }
  /*mistake undo*/
  validate=moves.map((v,i)=>v==scr[i] || (v[0]==scr[i][0] && ((i+1)==moves.length)))
  if(!validate.includes(false)){
    if(moves[moves.length-1] == scr[moves.length-1]){
      return "<a style=\"color:#008800;font-size:30\">"+moves.join(' ')+"</a>"+"<a style=\"color:#000000;font-size:30\"> "+scr.slice(moves.length).join(' ')+"</a>"
    }else{
      return "<a style=\"color:#008800;font-size:30\">"+moves.slice(0,-1).join(' ')+"</a>"+"<a style=\"color:#888800;font-size:30\"> "+scr[moves.length-1]+"</a>"+"<a style=\"color:#000000;font-size:30\"> "+scr.slice(moves.length).join(' ')+"</a>"
    }
  }else{
    wrongInd = validate.indexOf(false)
    correction = moves.slice(wrongInd).reverse().map(x=>x[0]+(x.length==1?"'":x[1]=="'"?"":"2"))
    return "<a style=\"color:#880000;font-size:30\">"+correction.join(' ')+"</a> "
  }
}

var tmpScrambleMoves=[]
var tmpScramble=[]
function scramblePrinter(event){
  /*show initial scramble*/
  if(buttonBLD.innerText === "BLD train in progress..." && TrainMode.value!='Pairity'  && TrainMode.value!='Corners 3-twists' && TrainMode.value!='Edges 2-flips'){
    if(status_train == 0){
      tmpScramble=scramblesBLD[alg_no].split(' ')
      document.getElementById('scramble').innerHTML=compareMovesToScr([],tmpScramble)
      status_train =1;
      startMoves=[]
    }
    else if(status_train ==1){
        if(extractBits(event,0,4)==2){
          lastMove=movesCube[extractBits(event,12,5)]
          /*append Moves to tmpScramblemoves*/
          if(tmpScrambleMoves.length == 0){
            tmpScrambleMoves=tmpScrambleMoves.concat(movesCube[extractBits(event,12,5)])}
          else if(lastMove[0] == tmpScrambleMoves.at(-1)[0]){
            turns = ((lastMove.length==1?1:lastMove[1]=="'"?3:2)+(tmpScrambleMoves.at(-1).length==1?1:tmpScrambleMoves.at(-1)[1]=="'"?3:2))%4
            if(turns == 0){tmpScrambleMoves.pop()}
            else{
              turnStr=turns==1?"":turns==2?"2":"'"
              tmpScrambleMoves[tmpScrambleMoves.length-1] = tmpScrambleMoves[tmpScrambleMoves.length-1][0]+turnStr
            }
          }
          else{
            tmpScrambleMoves.push(lastMove)
          }
          /*compare to actual scramble*/
        document.getElementById('scramble').innerHTML=compareMovesToScr(tmpScrambleMoves,tmpScramble)
        }
    }
    else if(status_train==2){
      logMessages={};
      document.getElementById('logBld').innerHTML=""
      document.getElementById('scramble').innerHTML="<br> Do U U' to begin memo"
      if(extractBits(event,0,4) == 2){
        startMoves=startMoves.concat(movesCube[extractBits(event,12,5)])
        if(startMoves.length==2){
          if((startMoves[0][0]==startMoves[1][0]) && (startMoves[0][1]!=startMoves[1][1])){
            console.log('memo start')
            stMemo=Date.now();
            status_train=3;
            startMoves=[]
            document.getElementById('logBld').innerHTML=""
          }else{
            console.log('wrong moves! do next scramble')
            status_train=4;
          }
        }
      }
    }
    else if(status_train==3){
      document.getElementById("scramble").innerHTML="Memo: "+String(Math.round((Date.now()-stMemo),2)/1000)
      reset=1;
      activateBLDRegister=1;
      if(extractBits(event,0,4) == 2){
        console.log('solve start')
        stExec=Date.now();
        addLog('memo '+String(Math.round((stExec-stMemo),2)/1000),"")
        status_train=4;
        // document.getElementById("scramble").innerHTML+="<br> Exec: "+String(Math.round((Date.now()-stExec),2)/1000)+"<br> Total: "+String(Math.round((Date.now()-stMemo),2)/1000)
      }
    }
    else if(status_train==4){
        end=Date.now();
        if(acjs_cube['kostka'].map(x => x.join('')).join('') == solved_cube.map(x => x.join('')).join('')){
        // document.getElementById("scramble").innerHTML="<br> Exec: "+String(Math.round((Date.now()-stExec),2)/1000)+"<br> Total: "+String(Math.round((Date.now()-stMemo),2)/1000)
          alg_no=alg_no+1;
          tmpScramble=[];
          tmpScrambleMoves=[];
          status_train=0
          if(alg_no>=scramblesBLD.length){
            logMessages={};
            updateButtonBLD();}
        }
    }


  }
}

var badalgs=[];
function updateButtonPLL() {
  if (buttonPLL.innerText === 'PLL train') {
    badalgs=[];
    pllToTrain=pll_algs.shuffle().slice(0,20);
    copy_cube(acjs_cube['kostka'],solved_cube)
    buttonPLL.innerText += ' in progress...';
  } else {
    alg_no=0;
    status_train=0;
    buttonPLL.innerText = buttonPLL.innerText.slice(0,-15);
    document.getElementById('tmpsaver').innerHTML=''
    document.getElementById('tmpsaverbad').innerHTML=''
  }
}
var active_bld_el='edges BLD'
var active_buf="UF"
function updateGlobalVars(typeEl){
  /*update choose list*/
  console.log(typeEl.target.name)
  // active_bld_el='edges BLD'
  // console.log('updating vars',typeEl.target.id)
  active_bld_el_dict=(["firstTargetC","bufferCorners"].includes(typeEl.target.id))?"corners":"edges"
  active_first_let_el_name='firstTarget'+(active_bld_el=='edges BLD'?'':'C')
  // active_buf=document.getElementById('buffer'+(active_bld_el=='edges'?'Edges':'Corners')).value
  /*update first target lists*/
  active_bld_el=(["firstTargetC","bufferCorners"].includes(typeEl.target.id))?"corners BLD":"edges BLD"
  active_buf=document.getElementById('buffer'+(active_bld_el=='edges BLD'?'Edges':'Corners')).value
  if(typeEl.target.name.slice(0,6) == 'buffer'){
    firstTargets = Object.keys(letter_stickers[active_bld_el_dict][active_buf])
    document.getElementById(active_first_let_el_name).innerHTML=""
    for(i=0;i<firstTargets.length;i++){
      document.getElementById(active_first_let_el_name).innerHTML+="<option value=\""+firstTargets[i]+"\">"+firstTargets[i]+"</option>"}
  }
  active_first_let=document.getElementById('firstTarget'+(active_bld_el=='edges BLD'?'':'C')).value
  pairsTable=generatePairs(active_bld_el=="edges BLD"?'edges':'corners',active_buf,active_first_let).flat().map(x=>x.join('')).shuffle()
  // console.log(times['corners BLD'].UBR.CT,pairsTable,active_bld_el,active_buf)
  generateTable(times,pairsTable,active_bld_el,active_buf)
  var cells = document.querySelectorAll('td:not(:first-child)');
  cells.forEach(function(cell) {
    var cellValue = cell.innerHTML.trim();
      if(cellValue.match(/[A-Z]{1,2}/)){ 
                  cell.classList.toggle('selected');
                  cell.addEventListener('click', function() {
                      // Toggle the selected class on the clicked cell
                      // console.log('poszklo')
                      cell.classList.toggle('selected');
                      if(cell.classList[0] === undefined){pairsTable.splice(pairsTable.indexOf(cellValue),1)}else{pairsTable.push(cellValue)}
                        // console.log(pairsTable)
                        updatePairs(pairsTable)
                        // console.log(pairs)
                  });}
  });
  var cellUp = document.querySelectorAll('th')[5]
  cellUp.addEventListener('click',function(){
    cellUp.classList.toggle('selected')
        switchCell=cellUp.classList[0]===undefined?0:1
        cells.forEach(function(upCell){
          var cellValue = upCell.innerHTML.trim();
          if(cellValue.match(/[A-Z]{2}/)){ 
            shouldUpdate= switchCell==(upCell.classList[0] === undefined?0:1)?false:true
            if(shouldUpdate){
              upCell.classList.toggle('selected')
          }}
        })
          pairsTable=[]
          if(switchCell == 1){
            pairsTable=generatePairs(active_bld_el=="edges BLD"?'edges':'corners',active_buf,active_first_let).flat().map(x=>x.join('')).shuffle()
          }
          updatePairs(pairsTable)
        
  })
}

function updatePairity(typeEl){
console.log(typeEl.target.value)
  if(typeEl.target.value==='Pairity'){
  pairsTable=pairityStates
  // console.log(times['corners BLD'].UBR.CT,pairsTable,active_bld_el,active_buf)
  generateTablePairity(times)
  var cells = document.querySelectorAll('td:not(:first-child)');
  cells.forEach(function(cell) {
    var cellValue = cell.innerHTML.trim();
      if(cellValue.match(/^[A-Z]{1}$/)){ 
                  cell.classList.toggle('selected');
                  cell.addEventListener('click', function() {
                      // Toggle the selected class on the clicked cell
                      // console.log('poszklo')
                      cell.classList.toggle('selected');
                      if(cell.classList[0] === undefined){pairsTable.splice(pairsTable.indexOf(cellValue),1)}else{pairsTable.push(cellValue)}
                        // console.log(pairsTable)
                        updatePairsPairity(pairsTable)
                        // console.log(pairs)
                  });}
  });
  var cellUp = document.querySelectorAll('th')[5]
  cellUp.addEventListener('click',function(){
    cellUp.classList.toggle('selected')
        switchCell=cellUp.classList[0]===undefined?0:1
        cells.forEach(function(upCell){
          var cellValue = upCell.innerHTML.trim();
          if(cellValue.match(/^[A-Z]{1}$/)){ 
            shouldUpdate= switchCell==(upCell.classList[0] === undefined?0:1)?false:true
            if(shouldUpdate){
              upCell.classList.toggle('selected')
          }}
        })
          pairsTable=[]
          if(switchCell == 1){
            pairsTable=pairityStates
          }
          updatePairsPairity(pairsTable)
        
  })}else if(typeEl.target.value === 'Corners 3-twists'){
  pairsTable=generatePairs3Twists(cuber,'UFR')[0].slice()
  console.log('pairsTable defined')
  // console.log(times['corners BLD'].UBR.CT,pairsTable,active_bld_el,active_buf)
  generateTableCorner3Twists(times)
  var cells = document.querySelectorAll('td:not(:first-child)');
  cells.forEach(function(cell) {
    var cellValue = cell.innerHTML.trim();
      if(cellValue.match(/^[A-Z]{2}$/)){ 
                  cell.classList.toggle('selected');
                  cell.addEventListener('click', function() {
                      // Toggle the selected class on the clicked cell
                      // console.log('poszklo')
                      cell.classList.toggle('selected');
                      if(cell.classList[0] === undefined){pairsTable.splice(pairsTable.indexOf(cellValue),1)}else{pairsTable.push(cellValue)}
                        // console.log(pairsTable)
                        updatePairs3twists(pairsTable)
                        // console.log(pairs)
                  });}
  });
  var cellUp = document.querySelectorAll('th')[5]
  cellUp.addEventListener('click',function(){
    cellUp.classList.toggle('selected')
        switchCell=cellUp.classList[0]===undefined?0:1
        cells.forEach(function(upCell){
          var cellValue = upCell.innerHTML.trim();
          if(cellValue.match(/^[A-Z]{2}$/)){ 
            shouldUpdate= switchCell==(upCell.classList[0] === undefined?0:1)?false:true
            if(shouldUpdate){
              upCell.classList.toggle('selected')
          }}
        })
          pairsTable=[]
          if(switchCell == 1){
            pairsTable=generatePairs3Twists(cuber,'UFR')[0]
          }
          updateTableCorners3Twists(times,pairsTable)
        
  })

  }else if(typeEl.target.value === 'Edges 2-flips'){
  pairsTable=generatePairs2Flips(cuber,'UF')[0].slice()
  console.log('pairsTable defined')
  // console.log(times['corners BLD'].UBR.CT,pairsTable,active_bld_el,active_buf)
  generateTableEdges2Flips(times)
  var cells = document.querySelectorAll('td:not(:first-child)');
  cells.forEach(function(cell) {
    var cellValue = cell.innerHTML.trim();
      if(cellValue.match(/^[A-Z_]{2}$/)){ 
                  cell.classList.toggle('selected');
                  cell.addEventListener('click', function() {
                      // Toggle the selected class on the clicked cell
                      // console.log('poszklo')
                      cell.classList.toggle('selected');
                      if(cell.classList[0] === undefined){pairsTable.splice(pairsTable.indexOf(cellValue),1)}else{pairsTable.push(cellValue)}
                        // console.log(pairsTable)
                        updatePairs2flips(pairsTable)
                        // console.log(pairs)
                  });}
  });
  var cellUp = document.querySelectorAll('th')[5]
  cellUp.addEventListener('click',function(){
    cellUp.classList.toggle('selected')
        switchCell=cellUp.classList[0]===undefined?0:1
        cells.forEach(function(upCell){
          var cellValue = upCell.innerHTML.trim();
          if(cellValue.match(/^[A-Z_]{2}$/)){ 
            shouldUpdate= switchCell==(upCell.classList[0] === undefined?0:1)?false:true
            if(shouldUpdate){
              upCell.classList.toggle('selected')
          }}
        })
          pairsTable=[]
          if(switchCell == 1){
            pairsTable=updatePairs2flips(cuber,'UF')[0]
          }
          updateTableEdges2Flips(times,pairsTable)
        
  })

  }
}

// function update3twists(){

//   pairsTable=generatePairs3Twists(cuber,'UFR')[0]
//   // console.log(times['corners BLD'].UBR.CT,pairsTable,active_bld_el,active_buf)
//   generateTableCorner3Twists(times)
//   var cells = document.querySelectorAll('td:not(:first-child)');
//   cells.forEach(function(cell) {
//     var cellValue = cell.innerHTML.trim();
//       if(cellValue.match(/^[A-Z]{2}$/)){ 
//                   cell.classList.toggle('selected');
//                   cell.addEventListener('click', function() {
//                       // Toggle the selected class on the clicked cell
//                       // console.log('poszklo')
//                       cell.classList.toggle('selected');
//                       if(cell.classList[0] === undefined){pairsTable.splice(pairsTable.indexOf(cellValue),1)}else{pairsTable.push(cellValue)}
//                         // console.log(pairsTable)
//                         updatePairsPairity(pairsTable)
//                         // console.log(pairs)
//                   });}
//   });
//   var cellUp = document.querySelectorAll('th')[5]
//   cellUp.addEventListener('click',function(){
//     cellUp.classList.toggle('selected')
//         switchCell=cellUp.classList[0]===undefined?0:1
//         cells.forEach(function(upCell){
//           var cellValue = upCell.innerHTML.trim();
//           if(cellValue.match(/^[A-Z]{1}$/)){ 
//             shouldUpdate= switchCell==(upCell.classList[0] === undefined?0:1)?false:true
//             if(shouldUpdate){
//               upCell.classList.toggle('selected')
//           }}
//         })
//           pairsTable=[]
//           if(switchCell == 1){
//             pairsTable=generatePairs3Twists(cuber,'UFR')[0]
//           }
//           updateTableCorners3Twists(times,pairsTable)
        
//   })
// }

function updatePairs(pairsTable){
    buf=active_buf
    console.log(buf)
      expected_states=[]
    alg_no=0;
    status_train=0;
    cuber.identity()
    /*force dummy smth*/
    permuteCycleCorners(cuber,'UFR',"AT");
    permuteCycleEdges(cuber,'UF',"AT");
    // console.log(pairsTable)
    if(pairsTable.length>0){
        for(i=0;i<pairsTable.length;i++){
          cuber.identity()
          // console.log(buf,pairsTable[i])
          if(buf.length==3){
                permuteCycleCorners(cuber,buf,pairsTable[i])}else{
                permuteCycleEdges(cuber,buf,pairsTable[i])
                }
          expected_states=expected_states.concat(cuber.asString())
        }}
}

function updatePairs3twists(pairsTable){
    buf=active_buf
    console.log(buf)
    expected_states=[]
    alg_no=0;
    status_train=0;
    cuber.identity()
    pairsTable=pairsTable.shuffle()
    /*force dummy smth*/
    permuteCycleCorners(cuber,'UFR',"AT");
    permuteCycleEdges(cuber,'UF',"AT");
    // console.log(pairsTable)
    if(pairsTable.length>0){
      allPairsStates=generatePairs3Twists(cuber,'UFR')[1]
      allLPs=generatePairs3Twists(cuber,'UFR')[0]
      expected_states=[]
      allPairs=allPairsStates
        for(i=0;i<pairsTable.length;i++){
                expected_states=expected_states.concat(allPairsStates[allLPs.indexOf(pairsTable[i])])
          }
        }
}

function updatePairs2flips(pairsTable){
    buf=active_buf
    console.log(buf)
    expected_states=[]
    alg_no=0;
    status_train=0;
    cuber.identity()
    pairsTable=pairsTable.shuffle()
    /*force dummy smth*/
    permuteCycleCorners(cuber,'UFR',"AT");
    permuteCycleEdges(cuber,'UF',"AT");
    // console.log(pairsTable)
    if(pairsTable.length>0){
      allPairsStates=generatePairs2Flips(cuber,'UF')[1]
      allLPs=generatePairs2Flips(cuber,'UF')[0]
      expected_states=[]
      allPairs=allPairsStates
        for(i=0;i<pairsTable.length;i++){
                expected_states=expected_states.concat(allPairsStates[allLPs.indexOf(pairsTable[i])])
          }
        }
}

function updatePairsPairity(pairsTable){
    expected_states=[]
    alg_no=0;
    status_train=0;
    cuber.identity()
    /*force dummy smth*/
    permuteCycleCorners(cuber,'UFR',"AT");
    permuteCycleEdges(cuber,'UF',"AT");
    // console.log(pairsTable)
    if(pairsTable.length>0){
        for(i=0;i<pairsTable.length;i++){
          cuber.identity()
          // console.log(buf,pairsTable[i])
          generatePairity(cuber,cornerSwap=[[0,0],sticker_map.corners[letter_stickers.corners.UFR[pairsTable[i]]]],edgesSwap=[[0,0],[1,0]])
          expected_states=expected_states.concat(cuber.asString())
        }}
}



const pairityStates=Object.keys(letter_stickers.corners.UFR)

function updateButtonCorners() {
  if (buttonCorners.innerText === 'BLD corners train') {
    active_bld_el='corners BLD'
    buf=document.getElementById('bufferCorners').value
    active_buf=buf
    ft=document.getElementById('firstTargetC').value
    pairs=pairsTable.shuffle();
    updatePairs(pairs)
    copy_cube(acjs_cube['kostka'],solved_cube)
    acjs_paint['kostka']()
    buttonCorners.innerText += ' in progress...';
  } else {
    alg_no=0;
    status_train=0;
    buttonCorners.innerText = buttonCorners.innerText.slice(0,-15);
    document.getElementById('tmpsaver').innerHTML=''
    document.getElementById('tmpsaverbad').innerHTML=''
    pairsAll=generatePairs(active_bld_el=="edges BLD"?'edges':'corners',active_buf,active_first_let).flat().map(x=>x.join(''))
    updateTable(times,pairsAll,active_bld_el,active_buf)
  }
}

function updateButtonEdges() {
  if (buttonEdges.innerText === 'BLD edges train') {
    buf=document.getElementById('bufferEdges').value
    ft=document.getElementById('firstTarget').value
    pairs=pairsTable.shuffle();
    expected_states=[]
    updatePairs(pairs)
    copy_cube(acjs_cube['kostka'],solved_cube)
    acjs_paint['kostka']()
    buttonEdges.innerText += ' in progress...';
  } else {
    alg_no=0;
    status_train=0;
    buttonEdges.innerText = buttonEdges.innerText.slice(0,-15);
    document.getElementById('tmpsaver').innerHTML=''
    document.getElementById('tmpsaverbad').innerHTML=''
    pairsAll=generatePairs(active_bld_el=="edges BLD"?'edges':'corners',active_buf,active_first_let).flat().map(x=>x.join(''))
    updateTable(times,pairsAll,active_bld_el,active_buf)
  }
}

function updateButtonReset() {
    if((button.innerText==='WV train') && (buttonPLL.innerText==='PLL train')){
        copy_cube(acjs_cube['kostka'],solved_cube)
        acjs_paint['kostka']()}
        else{
          console.log('cannot reset cube while training')
        }
}

function concatAlgs(a,b){
    tmp=b.slice().reverse()
    tmpa=a.slice()
    while(tmp[tmp.length-1][0] == tmpa[tmpa.length-1][0]){
        rep=[tmp.pop(),tmpa.pop()]
        dir=rep.map(x=>x.length==1?1:x[1]=="2"?2:3)
        mv=(dir[0]+dir[1]) % 4
        if(mv!=0){
            dirStr=(mv==1?"":mv==2?"2":"'");
            tmp.push(rep[0][0]+dirStr)}
        //cancelation
        if((tmp.length==0) || (tmpa.length==0)){return(a.concat(tmp.reverse()))}
    }
    return(tmpa.concat(tmp.reverse()))
}

var status_train=0;

// var t=Date.now() / 100
// setRotY(acjs_eye['kostka'],t,baseVal);
// setRotY(acjs_eyeX['kostka'],t,baseValX);
// setRotY(acjs_eyeY['kostka'],t,baseValY);
// acjs_paint['kostka']();
function copy_cube(dest, src) {            // copy 6x9 array of 54 facelets
  for (var i=0; i < src.length; i++)
    dest[i] = src[i].slice();
}

/*should be invoked on move event*/
reset=1
identityCube = new Cube();
edgesBufIndexes = Object.keys(letter_stickers.edges).map(x=>sticker_map.edges[x][0])
cornersBufIndexes = Object.keys(letter_stickers.corners).map(x=>sticker_map.corners[x][0])
logMessages={}
/*message : moves //case name : ts, tsdiff*/
function addLog(key,message){
  if(Object.keys(logMessages).includes(key)){
    logMessages[key]=logMessages[key].concat(message);
  }else{
    logMessages[key]=[message];
  }
  // document.getElementById('logBld').innerHTML=""
  // for(i=0;i<Object.keys(logMessages).length;i++){
  //   document.getElementById('logBld').innerHTML+=("// "+Object.keys(logMessages)[i]+"<br>"+logMessages[Object.keys(logMessages)[i]].join('<br>')+"<br>")
  // }
  if(key=='//memo'){
    document.getElementById('logBld').innerHTML+=message+"//"+key+"<br>"}
  else{
    document.getElementById('logBld').innerHTML+=algMoves.join(' ')+"//"+key+" "+message+" "+String(Math.round((Date.now()-stMemo),2)/1000)+'/'+String(Math.round((Date.now()-stAlg),2)/1000)+"<br>"
  }
}
function translateMoves(moves, el_type){
  console.log(event,Date.now())
}

function BLDStateRegister(event){
  if(reset == 1){
    identityCube.identity()
    stAlg=Date.now()
    // logMessages={}
    // document.getElementById('logBld').innerHTML=""
    reset=0
    checkCancel=1
    threshold=4
    algMoves=[]
    movesSearch=[["R","L","U","D","F","B","R'","L'","F'","B'","U'","D'"],["","R","L","U","D","F","B","R'","L'","F'","B'","U'","D'"]]
  }
  if((extractBits(event,0,4) == 2)){
    identityCube.move(movesCubeBLD[extractBits(event,12,5)])
    algMoves=algMoves.concat(movesCubeBLD[extractBits(event,12,5)])
    // console.log(movesCubeBLD[extractBits(event,12,5)])
  }
  detectBLDCase(identityCube)
  /*detect cancelation IN PROGRESS*/
  /*POC: init solver after x moves(x=5) and if moves required to solve<=2, and after next move it increases it should be consider as move cancel*/

  // if(algMoves.length>threshold){
  //   threshold+=1
  //   var typesw='';
  //   var lmsg='';
  //   for(i=0;i<movesSearch[0].length;i++){
  //     for(j=0;j<movesSearch[1].length;j++){
  //       identityCube.move([movesSearch[0][i],movesSearch[1][j]])
  //       [typesw,lmsg] = detectBLDCase(identityCube,false)
  //       if(typesw!=''){
  //         console.log('moves to do: '+movesSearch[0][i]+' '+movesSearch[1][j]+' to have '+lmsg)
  //       }
  //       identityCube.move(invAlg([movesSearch[0][i],movesSearch[1][j]]))
  //     }
  //   }

  // }
}

function detectBLDCase(cube,logEnabled=true){
  edCycle=[...Array(12).keys()].map(x=>cube.ep.indexOf(x)).filter((i,v)=> i!=v)
  edTwists=[...Array(12).keys()].map(x=>cube.ep.indexOf(x)).filter((i,v)=> (i===v) && (cube.eo[i] != 0))
  corCycle=[...Array(8).keys()].map(x=>cube.cp.indexOf(x)).filter((i,v)=> i!=v)
  corTwists=[...Array(8).keys()].map(x=>cube.cp.indexOf(x)).filter((i,v)=> (i===v) && (cube.co[i] != 0))
  logMsg=""
  /*detect cycle for edges*/
  if((edCycle.length==3) && (edTwists.length==0) && (corCycle.length==0) && (corTwists.length==0)){
    for(i=0;i<edgesBufIndexes.length;i++){
      typeSwitch=""
      if(edCycle.includes(edgesBufIndexes[i])){
        bufName=Object.keys(letter_stickers.edges)[i]
        typeSwitch="edges "+ bufName
        // console.log(typeSwitch)
        bufInd=edCycle.indexOf(edgesBufIndexes[i])
        edCycle=(cube.ep[edCycle[bufInd]]==edCycle[(bufInd+1)%3]?[edCycle[bufInd],edCycle[(bufInd+2)%3],edCycle[(bufInd+1)%3]]:[edCycle[bufInd],edCycle[(bufInd+1)%3],edCycle[(bufInd+2)%3]])
        break
      }
    }
    if(typeSwitch!=""){
        // console.log(edCycle)
        /*find order*/
        // lpNumInd=[bufInd,(bufInd+1)%3,(bufInd+2)%3]
        /*reorder according to buffer*/
        // console.log(edCycle)
        edCycle = [edCycle[1],edCycle[2]]
        // console.log(edCycle)
        // console.log(cube.ep,cube.eo)
        // console.log(cube.eo[edCycle[0]],cube.eo[edCycle[1]])
        edTwists = [cube.eo[edCycle[0]],(2+cube.eo[edCycle[1]]-cube.eo[edCycle[0]])%2]
        // console.log(edTwists)
        logMsg=[[letter_stickers_rev.edges[bufName][sticker_map_rev.edges[edTwists[0]][edCycle[0]]],letter_stickers_rev.edges[bufName][sticker_map_rev.edges[edTwists[1]][edCycle[1]]]].join(''),[sticker_map_rev.edges[edTwists[0]][edCycle[0]],sticker_map_rev.edges[edTwists[1]][edCycle[1]]].join('-')].join(', ')
        if(logEnabled){
                addLog(typeSwitch,logMsg)}
        // logMes={typeSwitch:[sticker_map_rev.edges[edTwists[0]][edCycle[0]],sticker_map_rev.edges[edTwists[1]][edCycle[1]]]}
        }
    else{
        edCycle = (cube.ep[edCycle[0]]==edCycle[1]?[edCycle[0],edCycle[2],edCycle[1]]:[edCycle[0],edCycle[1],edCycle[2]])
        edTwists = [0,cube.eo[edCycle[0]],(2+cube.eo[edCycle[1]]-cube.eo[edCycle[0]])%2]
        typeSwitch='edges outside buffers'
        logMsg=[sticker_map_rev.edges[edTwists[0]][edCycle[0]],sticker_map_rev.edges[edTwists[1]][edCycle[1]],sticker_map_rev.edges[edTwists[2]][edCycle[2]]].join('-')
        if(logEnabled){
                addLog(typeSwitch,logMsg)}
        // console.log({"edges outsite buffers":[sticker_map_rev.edges[edTwists[0]][edCycle[0]],sticker_map_rev.edges[edTwists[1]][edCycle[1]],sticker_map_rev.edges[edTwists[2]][edCycle[2]]]})
      }
    if(logEnabled){
        reset=1}
  }
  if((edCycle.length==0) && (edTwists.length==0) && (corCycle.length==3) && (corTwists.length==0)){
    for(i=0;i<cornersBufIndexes.length;i++){
      typeSwitch=""
      if(corCycle.includes(cornersBufIndexes[i])){
        bufName=Object.keys(letter_stickers.corners)[i]
        typeSwitch="corners "+bufName
        // console.log(typeSwitch)
        bufInd=corCycle.indexOf(cornersBufIndexes[i])
        corCycle=(cube.cp[corCycle[bufInd]]==corCycle[(bufInd+1)%3]?[corCycle[bufInd],corCycle[(bufInd+2)%3],corCycle[(bufInd+1)%3]]:[corCycle[bufInd],corCycle[(bufInd+1)%3],corCycle[(bufInd+2)%3]])
        break
      }
    }
    if(typeSwitch!=""){
        // console.log(corCycle)
        /*find order*/
        // lpNumInd=[bufInd,(bufInd+1)%3,(bufInd+2)%3]
        /*reorder according to buffer*/
        corCycle = [corCycle[1],corCycle[2]]
        // console.log(cube.co[corCycle[0]],cube.co[corCycle[1]])
        corTwists = [cube.co[corCycle[0]],(3+cube.co[corCycle[1]]+cube.co[corCycle[0]])%3]
        // console.log(corTwists)
        logMsg=[[letter_stickers_rev.corners[bufName][sticker_map_rev.corners[corTwists[0]][corCycle[0]]],letter_stickers_rev.corners[bufName][sticker_map_rev.corners[corTwists[1]][corCycle[1]]]].join(''),[sticker_map_rev.corners[corTwists[0]][corCycle[0]],sticker_map_rev.corners[corTwists[1]][corCycle[1]]].join('-')].join(', ')
        if(logEnabled){addLog(typeSwitch,logMsg)}
      }
    else{
        corCycle = (cube.cp[corCycle[0]]==corCycle[1]?[corCycle[0],corCycle[2],corCycle[1]]:[corCycle[0],corCycle[1],corCycle[2]])
        corTwists = [0,cube.co[corCycle[0]],(3+cube.co[corCycle[1]]-cube.co[corCycle[0]])%3]
        typeSwitch="corners outside buffers"
        logMsg=[sticker_map_rev.corners[corTwists[0]][corCycle[0]],sticker_map_rev.corners[corTwists[1]][corCycle[1]]].join('-')
        if(logEnabled){
                addLog(typeSwitch,logMsg)}
        // console.log({"corners outsite buffers":[sticker_map_rev.corners[corTwists[0]][corCycle[0]],sticker_map_rev.corners[corTwists[1]][corCycle[1]],sticker_map_rev.corners[corTwists[2]][corCycle[2]]]})
      }
      if(logEnabled){
          reset=1}
  }
  if((edCycle.length==0) && (edTwists.length==2) && (corCycle.length==0) && (corTwists.length==0)){
    // console.log("edges twist")
    typeSwitch="edges twist"
    logMsg=edTwists.map(x=>sticker_map_rev.edges[0][x]).join('-')
    if(logEnabled){
        addLog(typeSwitch,logMsg)
        reset=1}
  }
  if((edCycle.length==0) && (edTwists.length==0) && (corCycle.length==0) && (corTwists.length==2)){
    // console.log("corners twist")
    typeSwitch="corner twist"
    logMsg=corTwists.map(x=>sticker_map_rev.corners[0][x]).join('-')
     if(logEnabled){
    addLog(typeSwitch,logMsg)
    reset=1}
  }
  if((edCycle.length==2) && (edTwists.length==0) && (corCycle.length==2) && (corTwists.length==0)){
    typeSwitch="pairity: "
    logMsg=[[sticker_map_rev.edges[0][edCycle[0]],sticker_map_rev.edges[cube.eo[edCycle[0]]==1?1:0][edCycle[1]]].join('-'),
                        [sticker_map_rev.corners[0][corCycle[0]],sticker_map_rev.corners[cube.co[corCycle[0]]==1?1:corCycle[0]==2?2:0][corCycle[1]]].join('-')].join(', ')
     if(logEnabled){
    addLog(typeSwitch,logMsg)
    // console.log("pairity")
    reset=1}
  }
  if((edCycle.length==0) && (edTwists.length==0) && (corCycle.length==0) && (corTwists.length==3)){
     if(logEnabled){
    console.log("corners 3 twists")
    reset=1}
  }
  return typeSwitch,logMsg
}

copy_cube(tmp_cube,acjs_cube['kostka'])
// acjs_initialMove['kostka'].push('L');
let i = 0;
      async function connect() {
        try {
          const options = {
            filters: [{ namePrefix: "GAN" }],
            optionalServices: [
              "f95a48e6-a721-11e9-a2a3-022ae2dbcce4", // Unknown service, primary device
              "ec4cff6d-81fc-4e5b-91e0-8103885c9ae3", // Unknown characteristic, properties: Read and notify
              "f95a4b66-a721-11e9-a2a3-022ae2dbcce4", // Unknown characteristic, properties: Read
              "f95a5034-a721-11e9-a2a3-022ae2dbcce4", // Unknown characteristic, properties: Write
              "6e400001-b5a3-f393-e0a9-e50e24dc4179", // Unknown service, Primary device
              "28be4a4a-cd67-11e9-a32f-2a2ae2dbcce4", // Unknown characteristic, Properties: write and write without response
              "28be4cb6-cd67-11e9-a32f-2a2ae2dbcce4", // Unknown characteristic, Properties: Notify
              "00001800-0000-1000-8000-00805f9b34fb", // Generic access, primary device (UUID in long format)
              "00001801-0000-1000-8000-00805f9b34fb", // Generic attribute, primary device (UUID in long format)
              "00002902-0000-1000-8000-00805f9b34fb", // Client characteristic configuration (UUID in long format)
            ],
          };
          const device = await navigator.bluetooth.requestDevice(options);
          const server = await device.gatt.connect();
          console.log(device.name)
          console.log("Connected to GAN356i v3 smart cube");
          const service = await server.getPrimaryService(
            "6e400001-b5a3-f393-e0a9-e50e24dc4179"
          );
          const characteristic = await service.getCharacteristic(
            "28be4cb6-cd67-11e9-a32f-2a2ae2dbcce4"
          );
          const writeCharacteristic = await service.getCharacteristic(
            "28be4a4a-cd67-11e9-a32f-2a2ae2dbcce4"
          );
          // if( i == 1 ){
          //   let typedArray = Int32Array.from(encrypt(Array.from([4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),key,iv));
          //   return      writeCharacteristic.writeValueWithResponse(typedArray);
          //         i=i+1;
          //       }
          characteristic.addEventListener("characteristicvaluechanged", (event) => {

            // const value = event.target.value;
            //  let output = "";
            // // for (let i = 0; i < value.byteLength; i++) {
            //   output += value.getUint8(7).toString(16).padStart(2, "0") + " ";
            //   // }
            // console.log(output.trim());
            // document.getElementById("log").innerHTML += output.trim() + "<br>";
            if(i ==0){
                            init();
                            i+=1;}
                /*VW train scramble first init*/
                if((button.innerText == 'WV train in progress...') & (status_train==0)){
                  /*init cube*/
                    // console.log('setting up')/
                    copy_cube(acjs_cube['kostka'],wv_cube);
                    var setup_case=invAlg(scramble[alg_no].slice().split(' '));
                    if(Math.random()<.5){setup_case=back_moves(setup_case)}
                    setup_case.map(x => acjs_twistLayer['kostka'](acjs_cube['kostka'],'UDLRBF'.indexOf(x[0]),x.length == 1 ? 3:x[1]=="2"?2:1,0));
                    document.getElementById("scramble").innerHTML=setup_case.join(' ')
                    copy_cube(tmp_cube,acjs_cube['kostka']);
                    copy_cube(acjs_cube['kostka'],wv_cube);
                    status_train=1;
                    // acjs_paint['kostka']();
                }
                /*scrambling*/
                if((button.innerText == 'WV train in progress...') & (status_train==1)){
                    st=Date.now();
                    en=Date.now();
                    if(acjs_cube['kostka'].map(x => x.join('')).join('') == tmp_cube.map(x => x.join('')).join('')){
                      // alg_no+=1;
                      status_train=2;
                      
                    }
                  }

                if((button.innerText == 'WV train in progress...') & (status_train==2)){
                    en=Date.now();
                    document.getElementById("scramble").innerHTML = "GO!" + String(Math.round(en-st,2))+ "<br>"
                    if(acjs_cube['kostka'].map(x => x.join('')).join('') == wv_cube.map(x => x.join('')).join('')){
                      alg_no+=1;
                      status_train=0;
                      document.getElementById("log").innerHTML = String(Math.round(en-st,2))+ "<br>"
                      if((alg_no+1)>scramble.length){
                         updateButton();
                         alg_no=0;
                         document.getElementById("log").innerHTML="";
                         }
                    }
                  }
                /*PLL TRAIN*/
                if((buttonPLL.innerText == "PLL train in progress...") & (status_train==0)){
                  st=Date.now();
                  copy_cube(acjs_cube['kostka'],solved_cube);
                  setup_case=pllToTrain.slice()[alg_no]
                  document.getElementById("tmpsaver").innerHTML=setup_case.join(' ');
                  // setup_case.reverse();
                  aufStartrand=Math.random();
                  var aufStart = [aufStartrand<.25?"":aufStartrand<.5?"U":aufStartrand<.75?"U2":"U'"]
                  if(aufStartrand>=.25){
                    setup_case=aufStart.concat(setup_case)
                  }
                  setup_case.map(x => acjs_twistLayer['kostka'](acjs_cube['kostka'],movesD.indexOf(x[0]),x.length == 1 ? 1:x[1]==2?2:3,0));
                  status_train=1;
                  copy_cube(tmp_cube,acjs_cube['kostka']);
                  acjs_paint['kostka']();
                }
                if((buttonPLL.innerText == 'PLL train in progress...') & (status_train==1)){
                    en=Date.now();
                    if(acjs_cube['kostka'].map(x => x.join('')).join('') == solved_cube.map(x => x.join('')).join('')){
                      alg_no=alg_no+1;
                      console.log('next alg')
                      lastone=document.getElementById("tmpsaver").innerHTML.split(' ');
                      if(((en-st)/1000)>4){document.getElementById("tmpsaverbad").innerHTML+=lastone+";";console.log('saved case', lastone, badalgs)}
                      if((alg_no+1)>(pllToTrain.length)){
                         alg_no=0;
                         if(document.getElementById("tmpsaverbad").innerHTML.length>0){
                          pllToTrain=document.getElementById("tmpsaverbad").innerHTML.slice(0,-1).split(';').map(x=>x.split(','));
                          // console.log("repeating algs("+String(document.getElementById("tmpsaverbad").slice(0,-1).split(';').innerHTML.length)+" cases)");
                          document.getElementById("tmpsaverbad").innerHTML='';
                          document.getElementById("tmpsaver").innerHTML=''
                          repeating=1;}
                         else{
                         updateButtonPLL();
                         repeating=0}
                         }
                      status_train=0;
                      document.getElementById("log").innerHTML = String(Math.round((en-st),2)/1000)+ "<br>"
                    }
                  }
                /*EDGES TRAIN*/
                if((buttonEdges.innerText == "BLD edges train in progress...") & (status_train==0)){
                  count=mvcnt
                  st=Date.now();
                  st_reaction=Date.now();
                  copy_cube(acjs_cube['kostka'],solved_cube);
                  expected_state=expected_states[alg_no]
                  status_train=1;
                  document.getElementById("tmpsaver").innerHTML = "<p style=\"font-size:14px; \">" +pairsTable[alg_no]+ "</p>"
                }
                if((buttonEdges.innerText == 'BLD edges train in progress...') & (status_train==1)){
                    en=Date.now();
                    if(mvcnt==count){st_reaction=Date.now();}
                    if(convertAcjs(acjs_cube['kostka']) == expected_state){
                      times['edges BLD'][active_buf][pairs[alg_no]].reaction.push(Math.round((st_reaction-st),2)/1000)
                      times['edges BLD'][active_buf][pairs[alg_no]].exec_time.push(Math.round((en-st_reaction),2)/1000)
                      times['edges BLD'][active_buf][pairs[alg_no]].total_time.push(Math.round((en-st),2)/1000)
                      times['edges BLD'][active_buf][pairs[alg_no]].TPS.push((mvcnt-count)/(Math.round((en-st_reaction),2)/1000))
                      alg_no=alg_no+1;
                      console.log('next alg')
                      if((alg_no+1)>(expected_states.length)){
                         alg_no=0;
                         updateButtonEdges();
                         }
                      status_train=0;
                      document.getElementById("log").innerHTML = String(Math.round((en-st),2)/1000)+ "<br>"
                      updateJSONstorage(times)
                    }
                  }
                   /*Corners TRAIN*/
                if((buttonCorners.innerText == "BLD corners train in progress...") & (status_train==0)){
                  count=mvcnt
                  st=Date.now();
                  st_reaction=Date.now();
                  copy_cube(acjs_cube['kostka'],solved_cube);
                  expected_state=expected_states[alg_no]
                  status_train=1;
                  document.getElementById("tmpsaver").innerHTML = "<p style=\"font-size:14px; \">" +memo_map[pairsTable[alg_no]]+ "</p>"
                }
                if((buttonCorners.innerText == 'BLD corners train in progress...') & (status_train==1)){
                    en=Date.now();
                    if(mvcnt==count){st_reaction=Date.now();}
                    if(convertAcjs(acjs_cube['kostka']) == expected_state){
                      times['corners BLD'][active_buf][pairsTable[alg_no]].reaction.push(Math.round((st_reaction-st),2)/1000)
                      times['corners BLD'][active_buf][pairsTable[alg_no]].exec_time.push(Math.round((en-st_reaction),2)/1000)
                      times['corners BLD'][active_buf][pairsTable[alg_no]].total_time.push(Math.round((en-st),2)/1000)
                      times['corners BLD'][active_buf][pairsTable[alg_no]].TPS.push((mvcnt-count)/(Math.round((en-st_reaction),2)/1000))
                      alg_no=alg_no+1;
                      console.log('next alg')
                      if((alg_no+1)>(expected_states.length)){
                         alg_no=0;
                         updateButtonCorners();
                         }
                      status_train=0;
                      document.getElementById("log").innerHTML = String(Math.round((en-st),2)/1000)+ "<br>"
                      updateJSONstorage(times)
                    }
                  }
                   /*EDGES TRAIN MARATHON*/
                if((buttonEdgesM.innerText == "BLD edges marathon train in progress...") & (status_train==0)){
                  count=mvcnt
                  st=Date.now();
                  st_reaction=Date.now();
                  copy_cube(acjs_cube['kostka'],solved_cube);
                  expected_state=expected_states[alg_no]
                  // document.getElementById("tmpsaver").innerHTML=expected_state.join(' ');
                  status_train=1;
                  document.getElementById("tmpsaver").innerHTML = "<p style=\"font-size:14px; \">" +pairsTable[alg_no]+ "</p>"
                }
                if((buttonEdgesM.innerText == 'BLD edges marathon train in progress...') & (status_train==1)){
                    en=Date.now();
                    if(mvcnt==count){st_reaction=Date.now();}
                    if(convertAcjs(acjs_cube['kostka']) == expected_state){
                      times['edges BLD'][active_buf][pairsTable[alg_no]].reaction.push(Math.round((st_reaction-st),2)/1000)
                      times['edges BLD'][active_buf][pairsTable[alg_no]].exec_time.push(Math.round((en-st_reaction),2)/1000)
                      times['edges BLD'][active_buf][pairsTable[alg_no]].total_time.push(Math.round((en-st),2)/1000)
                      times['edges BLD'][active_buf][pairsTable[alg_no]].TPS.push((mvcnt-count)/(Math.round((en-st_reaction),2)/1000))
                      lastone=alg_no;
                      if(((en-st)/1000)>parseFloat(thEM.value)){document.getElementById("tmpsaverbad").innerHTML+=lastone+";"}
                      alg_no=alg_no+1;
                      status_train=0;
                      console.log('next alg')}
                      if((alg_no+1)>(expected_states.length)){
                         alg_no=0;
                         if(document.getElementById("tmpsaverbad").innerHTML.length>0){
                          expected_states=document.getElementById("tmpsaverbad").innerHTML.slice(0,-1).split(';').map(x=>expected_states[parseInt(x)]);
                          pairsTable=document.getElementById("tmpsaverbad").innerHTML.slice(0,-1).split(';').map(x=>pairsTable[parseInt(x)]);
                          // console.log("repeating algs("+String(document.getElementById("tmpsaverbad").slice(0,-1).split(';').innerHTML.length)+" cases)");
                          document.getElementById("tmpsaverbad").innerHTML='';
                          document.getElementById("tmpsaver").innerHTML=''
                        }else{
                                                 updateButtonBLDem();}
                      status_train=0;
                      document.getElementById("log").innerHTML = String(Math.round((en-st),2)/1000)+ "<br>"
                      updateJSONstorage(times)
                    }
                  }
              /*CORNERS TRAIN MARATHON*/
                if((buttonCornersM.innerText == "BLD corners marathon train in progress...") & (status_train==0)){
                  count=mvcnt
                  st=Date.now();
                  st_reaction=Date.now();
                  copy_cube(acjs_cube['kostka'],solved_cube);
                  expected_state=expected_states[alg_no]
                  // document.getElementById("tmpsaver").innerHTML=expected_state.join(' ');
                  status_train=1;
                  document.getElementById("tmpsaver").innerHTML = "<p style=\"font-size:14px; \">" +memo_map[pairsTable[alg_no]]+(((alg_no+1)==expected_states.length)?"":(","+memo_map[pairsTable[alg_no+1]]))+ "</p>"
                }
                if((buttonCornersM.innerText == 'BLD corners marathon train in progress...') & (status_train==1)){
                    en=Date.now();
                    if(mvcnt==count){st_reaction=Date.now();}
                    if(convertAcjs(acjs_cube['kostka']) == expected_state){
                      times['corners BLD'][active_buf][pairsTable[alg_no]].reaction.push(Math.round((st_reaction-st),2)/1000)
                      times['corners BLD'][active_buf][pairsTable[alg_no]].exec_time.push(Math.round((en-st_reaction),2)/1000)
                      times['corners BLD'][active_buf][pairsTable[alg_no]].total_time.push(Math.round((en-st),2)/1000)
                      times['corners BLD'][active_buf][pairsTable[alg_no]].TPS.push((mvcnt-count)/(Math.round((en-st_reaction),2)/1000))
                      lastone=alg_no;
                      console.log((mvcnt-count)/(Math.round((en-st_reaction),2)/1000))
                      if((((en-st)/1000)> parseFloat(thCM.value)) && ((mvcnt-count)/(Math.round((en-st_reaction),2)/1000) < 11)){document.getElementById("tmpsaverbad").innerHTML+=lastone+";"}
                      alg_no=alg_no+1;
                      status_train=0;
                      console.log('next alg')}
                      if((alg_no+1)>(expected_states.length)){
                         alg_no=0;
                         if(document.getElementById("tmpsaverbad").innerHTML.length>0){
                          expected_states=document.getElementById("tmpsaverbad").innerHTML.slice(0,-1).split(';').map(x=>expected_states[parseInt(x)]);
                          pairsTable=document.getElementById("tmpsaverbad").innerHTML.slice(0,-1).split(';').map(x=>pairsTable[parseInt(x)]);
                          // console.log("repeating algs("+String(document.getElementById("tmpsaverbad").slice(0,-1).split(';').innerHTML.length)+" cases)");
                          document.getElementById("tmpsaverbad").innerHTML='';
                          document.getElementById("tmpsaver").innerHTML=''
                        }else{
                                                 updateButtonBLDcm();}
                      status_train=0;
                      document.getElementById("log").innerHTML = String(Math.round((en-st),2)/1000)+ "<br>"
                      updateJSONstorage(times)
                    }
                  }
                 /*Pairity TRAIN*/
                if((buttonBLD.innerText == "BLD train in progress...") & (TrainMode.value=='Pairity') & (status_train==0)){
                  count=mvcnt
                  st=Date.now();
                  st_reaction=Date.now();
                  copy_cube(acjs_cube['kostka'],solved_cube);
                  expected_state=expected_states[alg_no]
                  status_train=1;
                  document.getElementById("tmpsaver").innerHTML = "<p style=\"font-size:14px; \">" +pairsTable[alg_no]+ "</p>"
                }
                if((buttonBLD.innerText == 'BLD train in progress...') & (TrainMode.value=='Pairity') & (status_train==1)){
                    en=Date.now();
                    if(mvcnt==count){st_reaction=Date.now();}
                    if(convertAcjs(acjs_cube['kostka']) == expected_state){
                      times["pairity UFR-x UF-UR"][pairsTable[alg_no]].reaction.push(Math.round((st_reaction-st),2)/1000)
                      times["pairity UFR-x UF-UR"][pairsTable[alg_no]].exec_time.push(Math.round((en-st_reaction),2)/1000)
                      times["pairity UFR-x UF-UR"][pairsTable[alg_no]].total_time.push(Math.round((en-st),2)/1000)
                      times["pairity UFR-x UF-UR"][pairsTable[alg_no]].TPS.push((mvcnt-count)/(Math.round((en-st_reaction),2)/1000))
                      alg_no=alg_no+1;
                      console.log('next alg')
                      if((alg_no+1)>(expected_states.length)){
                         alg_no=0;
                         updateButtonCorners();
                         }
                      status_train=0;
                      document.getElementById("log").innerHTML = String(Math.round((en-st),2)/1000)+ "<br>"
                      updateJSONstorage(times)
                    }
                  }

                  /*corners 3 twists train*/
               if((buttonBLD.innerText == "BLD train in progress...") & (TrainMode.value=='Corners 3-twists') & (status_train==0)){
                  count=mvcnt
                  st=Date.now();
                  st_reaction=Date.now();
                  copy_cube(acjs_cube['kostka'],solved_cube);
                  expected_state=expected_states[alg_no]
                  status_train=1;
                  document.getElementById("tmpsaver").innerHTML = "<p style=\"font-size:14px; \">" +pairsTable[alg_no]+ "</p>"
                }
                if((buttonBLD.innerText == 'BLD train in progress...') & (TrainMode.value=='Corners 3-twists') & (status_train==1)){
                    en=Date.now();
                    if(mvcnt==count){st_reaction=Date.now();}
                    if(convertAcjs(acjs_cube['kostka']) == expected_state){
                      times["corners BLD 3-twists"][pairsTable[alg_no]].reaction.push(Math.round((st_reaction-st),2)/1000)
                      times["corners BLD 3-twists"][pairsTable[alg_no]].exec_time.push(Math.round((en-st_reaction),2)/1000)
                      times["corners BLD 3-twists"][pairsTable[alg_no]].total_time.push(Math.round((en-st),2)/1000)
                      times["corners BLD 3-twists"][pairsTable[alg_no]].TPS.push((mvcnt-count)/(Math.round((en-st_reaction),2)/1000))
                      alg_no=alg_no+1;
                      console.log('next alg')
                      if((alg_no+1)>(expected_states.length)){
                         alg_no=0;
                         updateButtonBLD();
                         }
                      status_train=0;
                      document.getElementById("log").innerHTML = String(Math.round((en-st),2)/1000)+ "<br>"
                      updateJSONstorage(times)
                    }
                  }
                /*edges 2 flips train*/
               if((buttonBLD.innerText == "BLD train in progress...") & (TrainMode.value=='Edges 2-flips') & (status_train==0)){
                  count=mvcnt
                  st=Date.now();
                  st_reaction=Date.now();
                  copy_cube(acjs_cube['kostka'],solved_cube);
                  expected_state=expected_states[alg_no]
                  status_train=1;
                  document.getElementById("tmpsaver").innerHTML = "<p style=\"font-size:14px; \">" +pairsTable[alg_no]+ "</p>"
                }
                if((buttonBLD.innerText == 'BLD train in progress...') & (TrainMode.value=='Edges 2-flips') & (status_train==1)){
                    en=Date.now();
                    if(mvcnt==count){st_reaction=Date.now();}
                    if(convertAcjs(acjs_cube['kostka']) == expected_state){
                      times["edges 2-flips"][pairsTable[alg_no]].reaction.push(Math.round((st_reaction-st),2)/1000)
                      times["edges 2-flips"][pairsTable[alg_no]].exec_time.push(Math.round((en-st_reaction),2)/1000)
                      times["edges 2-flips"][pairsTable[alg_no]].total_time.push(Math.round((en-st),2)/1000)
                      times["edges 2-flips"][pairsTable[alg_no]].TPS.push((mvcnt-count)/(Math.round((en-st_reaction),2)/1000))
                      alg_no=alg_no+1;
                      console.log('next alg')
                      if((alg_no+1)>(expected_states.length)){
                         alg_no=0;
                         updateButtonBLD();
                         }
                      status_train=0;
                      document.getElementById("log").innerHTML = String(Math.round((en-st),2)/1000)+ "<br>"
                      updateJSONstorage(times)
                    }
                  }
                let value = event.target.value;
                let arrayBuffer = value.buffer.slice(value.byteOffset, value.byteOffset + value.byteLength);
                let dataArray = new Uint8Array(arrayBuffer);
                var array = Array.from(dataArray)
                // console.log('raw:',array)
                // console.log("Received encoded bytes: " +array)
                // console.log("Received raw bytes: " +array);
                // console.log(array);
                let result = decrypt(array, key, iv);
                let result8bit = new Uint8Array(result)
                // console.log('decrypted:',result)
                // let result = decrypt(value,aesKey,aesIv)
                // let bytes = new Uint8Array(ae);
                // value = decrypt(bytes, aesKey, aesIv);
                let bitsfirst = extractBits(result,0,4);
                scramblePrinter(result)
                if(activateBLDRegister==1){
                                BLDStateRegister(result)}
                // MOVES DATA
                // let lastmove = extractBits(result,13,4);
                // console.log(bitsfirst)
                let angle = extractBits(result,81, 7);
                let angle4= extractBits(result,129,7);
                let ori = extractBits(result,128,1);
                let ori2 = extractBits(result,80,1);
                    const anglex1=0;
                const anglex2=0;
                const anglex3=Math.floor(2*Math.atan2(angle*(ori2-.5),(angle4*(ori-.5)))/Math.PI*180)/360*2*Math.PI;
                if((bitsfirst == 2)){
                  // copy_cube(acjs_cube['kostka'],tmp_cube);
                  // console.log('UDLRBF'.indexOf(moves[extractBits(result,12,5)][0]),moves[extractBits(result,12,5)].length == 1 ? 1:3)
                  acjs_twistLayer['kostka'](acjs_cube['kostka'],'UDLRBF'.indexOf(moves[extractBits(result,12,5)][0]),moves[extractBits(result,12,5)].length == 1 ? 1:3,0)
                  mvcnt+=1;
                  acjs_paint['kostka']();
                  // translateMoves(movesCubeBLD[extractBits(result,12,5)]);
                  // copy_cube(tmp_cube,acjs_cube['kostka'])
                    // newCube('kostka',moves[extractBits(result,12,5)])
                    // allmoves.push(moves[extractBits(result,12,5)])
                    // console.log(extractBits(result,12,5));
                }

                

                // let back = encrypt(result,key,iv);
                // console.log('back',back);
                //parzyste wyciagnij
                // if((bitsfirst == 2) && ((i % 2) ==0)){
                //     console.log("Received decoded bytes: " +(result.map(x => byteString(x).replace(/0|1/g,function(u){return{'0':'','1':''}[u]}))).join(''));
                //     i=i+1;
                //     document.getElementById("log").innerHTML = result + "<br>";
                //   // console.log("Received decoded bytes: " +lastmove);
                //   }else if((bitsfirst == 2) && (i%2) ==1){i=i+1}
                 if((bitsfirst == 1)){
                  // console.log('provided value:',anglex3)
                  // requestAnimationFrame(animate);
                   // renderer.render(scene, camera);
                  // controls.update();
                  // console.log(anglex3)
                  // cube.rotation.set(0,anglex3,0);
                  rotCube(acjs_cube['kostka'],(buttonPLL.innerText == 'PLL train in progress...'?0:anglex3)+base_rot);
                    // regedges=/^.{47}/gi
                    // regedges2=/(.{4})/gi
                    // console.log("Received decoded bytes: " +(result.map(x => byteString(x).replace(/0|1/g,function(u){return{'0':'','1':''}[u]}))).join('|'));
                    // i=i+1;
                    // document.getElementById("log").innerHTML += result += "<br>";
                    // document.getElementById("log").innerHTML = [angle*(ori2-.5)*2,angle4*(ori-.5)*2,Math.floor(2*Math.atan2(angle*(ori2-.5),(angle4*(ori-.5)))/Math.PI*180)] + "<br>";
                  // console.log("Received decoded bytes: " +lastmove);
                  }

                // console.log(result);
          });
          await characteristic.startNotifications();
        } catch (error) {
          console.error("Bluetooth error:", error);
          document.getElementById("log").innerHTML += "Bluetooth error: " + error + "<br>";
        }

      }
      // function printData(){
      //   document.getElementById("log").innerHTML += result + "<br>";
      // }
          let scene, camera, renderer, controls;
    let cube;

    
    // const time=Date.now()*.00000000001;
    // console.log(time);
    
    // animate(angle1,angle2,angle3);
    // console.log(angle1,angle2,angle3);
    function init() {
      // Create a scene
      // scene = new THREE.Scene();
      
      // // Create a camera
      // camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      // camera.position.set(5, 5, 5);
      // scene.add(camera);
      
      // Create a renderer
      // renderer = new THREE.WebGLRenderer();
      // renderer.setSize(window.innerWidth, window.innerHeight);
      // document.body.appendChild(renderer.domElement);
      
      // // Create controls
      // controls = new THREE.OrbitControls(camera, renderer.domElement);
      
      // // Create a Rubik's Cube
      // const colors = [
      //   0xff0000, // red
      //   0x00ff00, // green
      //   0x0000ff, // blue
      //   0xffff00, // yellow
      //   0xffa500, // orange
      //   0xffffff  // white
      // ];
      // const cubeSize = 2;
      // const cubeGeo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
      // const materials = colors.map(color => new THREE.MeshStandardMaterial({color, roughness: 0.7}));
      // const cubeMat = new THREE.MeshFaceMaterial(materials);
      // cube = new THREE.Mesh(cubeGeo, cubeMat);
      // cube.position.set(0, 0, 0);
      // scene.add(cube);

      // // Set up lighting
      // const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      // const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      // directionalLight.position.set(10, 10, 0);
      // scene.add(ambientLight, directionalLight);
      
      // Set up window resize handler
      // window.addEventListener('resize', onWindowResize);
    }

    // function onWindowResize() {
    //   camera.aspect = window.innerWidth / window.innerHeight;
    //   camera.updateProjectionMatrix();
    //   renderer.setSize(window.innerWidth, window.innerHeight);
    // }
    </script>
   

  </body>

</html>